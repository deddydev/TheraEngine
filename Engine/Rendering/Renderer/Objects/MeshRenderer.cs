using Extensions;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using TheraEngine.Core;
using TheraEngine.Core.Maths.Transforms;
using TheraEngine.Rendering.Models.Materials;

namespace TheraEngine.Rendering.Models
{
    public enum EDrawElementType
    {
        Byte    = 0,
        UShort  = 2,
        UInt    = 4,
    }
    /// <summary>
    /// Used to render raw primitive data.
    /// </summary>
    public interface IMeshRenderer
    {
        int BindingId { get; }
        HashSet<int> ModifiedBoneIndicesRendering { get; }
        HashSet<int> ModifiedVertexIndicesRendering { get; }
        HashSet<int> ModifiedBoneIndicesUpdating { get; }
        HashSet<int> ModifiedVertexIndicesUpdating { get; }
        TMesh TargetMesh { get; set; }
        DataBuffer IndexBuffer { get; }
        TMaterial Material { get; set; }
        EDrawElementType ElementType { get; }

        void SwapBuffers();
        void SkeletonChanged(ISkeleton skeleton);
        T2 Parameter<T2>(int index) where T2 : ShaderVar;
        T2 Parameter<T2>(string name) where T2 : ShaderVar;
        void Render();
        void Render(int instances);
        void Render(Matrix4 modelMatrix, int instances = 1);
        void Render(Matrix4 modelMatrix, TMaterial material, int instances = 1);
        void Render(Matrix4 modelMatrix, Matrix3 normalMatrix, int instances = 1);
        void Render(Matrix4 modelMatrix, Matrix3 normalMatrix, TMaterial material, int instances = 1);
    }
    public delegate void DelPrimManagerSettingUniforms(RenderProgram vertexProgram, RenderProgram materialProgram);
    /// <summary>
    /// Used to render raw primitive data.
    /// </summary>
    public class MeshRenderer : BaseRenderObject, IMeshRenderer
    {
        /// <summary>
        /// Subscribe to this event to send your own uniforms to the material.
        /// </summary>
        public event DelPrimManagerSettingUniforms SettingUniforms;

        //Vertex buffer information
        private int[] _bindingIds;
        private IntPtr[] _offsets;
        private int[] _strides;
        private TMesh _mesh;
        private ProgramPipeline _pipeline; //Used to connect the material shader(s) to the vertex shader
        private RenderProgram _vertexProgram; //The autogenerated vertex shader program
        internal GLSLScript _vertexShader;

        protected IBone SingleBind
        {
            get => _singleBind;
            set
            {
                if (_singleBind != null)
                {
                    _singleBind.Renamed -= SingleBindRenamed;
                }
                _singleBind = value;
                if (_singleBind != null)
                {
                    _singleBind.Renamed += SingleBindRenamed;
                }
            }
        }

        //Skeleton information
        private IBone _singleBind;
        private IBone[] _utilizedBones;
        private bool _rigInvalidated = false;
        private Dictionary<int, int> _boneRemap;
        private bool _allowRender = true;
        private CPUSkinInfo _cpuSkinInfo; //Only used in CPU skinning mode
        //private bool _processingSkinning = false;

        public MeshRenderer() : base(EObjectType.VertexArray) { }
        public MeshRenderer(TMesh mesh, TMaterial material) : this()
        {
            if (Engine.Settings.AllowShaderPipelines)
                _pipeline = new ProgramPipeline();
            Material = material;
            TargetMesh = mesh;
        }

        /// <summary>
        /// Determines how to use the results of the <see cref="ConditionalRenderQuery"/>.
        /// </summary>
        public EConditionalRenderType ConditionalRenderType { get; set; } = EConditionalRenderType.QueryNoWait;
        /// <summary>
        /// A render query that is used to determine if this mesh should be rendered or not.
        /// </summary>
        public RenderQuery ConditionalRenderQuery { get; set; } = null;

        public VertexShaderDesc BufferInfo => _mesh?.BufferInfo;
        public int Instances { get; set; } = 1;

        //TODO: move vertex buffer allocations out of PrimitiveData and into this class, so the original PrimitiveData can be disposed of.
        /// <summary>
        /// This is the mesh object that will be rendered.
        /// </summary>
        public TMesh TargetMesh
        {
            get => _mesh;
            set
            {
                Destroy();
                if (IndexBuffer != null)
                {
                    IndexBuffer.Dispose();
                    IndexBuffer = null;
                }
                if (_mesh != null)
                {
                    _mesh.BufferInfoChanged -= OnBufferInfoChanged;
                }
                _mesh = value;
                if (_mesh != null)
                {
                    _mesh.BufferInfoChanged += OnBufferInfoChanged;
                    OnBufferInfoChanged();
                    
                    IndexBuffer = new DataBuffer("FaceIndices", EBufferTarget.ElementArrayBuffer, true);
                    var indices = _mesh.GetIndices();
                    //TODO: primitive restart will use MaxValue for restart id
                    if (_mesh.FacePoints.Count < byte.MaxValue)
                    {
                        ElementType = EDrawElementType.Byte;
                        IndexBuffer.SetDataNumeric(indices?.Select(x => (byte)x)?.ToList());
                    }
                    else if (_mesh.FacePoints.Count < short.MaxValue)
                    {
                        ElementType = EDrawElementType.UShort;
                        IndexBuffer.SetDataNumeric(indices?.Select(x => (ushort)x)?.ToList());
                    }
                    else
                    {
                        ElementType = EDrawElementType.UInt;
                        IndexBuffer.SetDataNumeric(indices);
                    }
                }
            }
        }

        private VertexShaderGenerator VtxShaderGen { get; } = new VertexShaderGenerator();
        private void OnBufferInfoChanged()
        {
            _vertexShader = VtxShaderGen.Generate(BufferInfo, Material, false, false, false);
            if (Engine.Settings.AllowShaderPipelines)
            {
                if (_vertexProgram != null && _vertexProgram.IsActive)
                    _vertexProgram.Destroy();
                
                _vertexProgram = new RenderProgram(_vertexShader);
                //_vertexProgram.Generate();
            }
        }

        public TMaterial Material { get; set; }
        public TMaterial GetRenderMaterial()
        {
            if (Material?.Program != null && Material.Program.IsValid)
                return Material;
            else
                return TMaterial.InvalidMaterial;
        }

        public RenderProgram VertexProgram
        {
            get
            {
                if (!Engine.Settings.AllowShaderPipelines)
                    return null;

                if (!IsActive)
                    Generate();

                return _vertexProgram;
            }
        }

        [Browsable(false)]
        public DataBuffer IndexBuffer { get; private set; }
        public EDrawElementType ElementType { get; private set; }
        [Browsable(false)]
        public RenderProgram VertexFragProgram { get; private set; }

        /// <summary>
        /// All vertices that have changed and are ready for render.
        /// Only used by CPU skinning.
        /// </summary>
        [Browsable(false)]
        public HashSet<int> ModifiedVertexIndicesRendering => _modifiedVertexIndicesRendering;
        /// <summary>
        /// All bones that have changed and are ready for render.
        /// Only used by GPU skinning.
        /// </summary>
        [Browsable(false)]
        public HashSet<int> ModifiedBoneIndicesRendering => _modifiedBoneIndicesRendering;
        /// <summary>
        /// All vertices that are currently changing.
        /// Only used by CPU skinning.
        /// </summary>
        [Browsable(false)]
        public HashSet<int> ModifiedVertexIndicesUpdating => _modifiedVertexIndicesUpdating;
        /// <summary>
        /// All bones that are currently changing.
        /// Only used by GPU skinning.
        /// </summary>
        [Browsable(false)]
        public HashSet<int> ModifiedBoneIndicesUpdating => _modifiedBoneIndicesUpdating;

        private HashSet<int> _modifiedVertexIndicesRendering = new HashSet<int>();
        private HashSet<int> _modifiedBoneIndicesRendering = new HashSet<int>();
        private HashSet<int> _modifiedVertexIndicesUpdating = new HashSet<int>();
        private HashSet<int> _modifiedBoneIndicesUpdating = new HashSet<int>();

        public void SwapBuffers()
        {
            THelpers.Swap(ref _modifiedVertexIndicesRendering, ref _modifiedVertexIndicesUpdating);
            THelpers.Swap(ref _modifiedBoneIndicesRendering, ref _modifiedBoneIndicesUpdating);
            _modifiedBoneIndicesUpdating.Clear();
            _modifiedVertexIndicesUpdating.Clear();
        }

        private void LinkMeshToSkeleton(bool set)
        {
            _allowRender = set;

            if (TargetMesh.Influences is null || _cpuSkinInfo is null)
                return;
            
            foreach (var inf in _cpuSkinInfo._influences)
            {
                for (int j = 0; j < inf._weightCount; ++j)
                {
                    IBone b = inf._bones[j];
                    if (set)
                    {
                        if (!b.TargetInfluences.Contains(inf))
                            b.TargetInfluences.Add(inf);
                    }
                    else
                    {
                        if (b.TargetInfluences.Contains(inf))
                            b.TargetInfluences.Remove(inf);
                    }
                }
            }

            foreach (FacePoint point in TargetMesh.FacePoints)
            {
                var infIndex = point?.InfluenceIndex ?? -1;
                if (!_cpuSkinInfo._influences.IndexInRange(infIndex))
                    continue;

                var inf = _cpuSkinInfo._influences[infIndex];
                if (inf is null)
                    continue;

                for (int j = 0; j < inf._weightCount; ++j)
                {
                    IBone b = inf._bones[j];
                    if (set)
                    {
                        List<int> list;

                        //if (!b._influencedVertices.ContainsKey(BindingId))
                        //    b._influencedVertices.Add(BindingId, list = new List<int>());
                        //else
                        list = b.TargetVertices[BindingId].Item2;

                        if (!list.Contains(point.Index))
                            list.Add(point.Index);
                    }
                    else
                    {
                        //if (b._influencedVertices.ContainsKey(BindingId))
                        //{
                        List<int> list = b.TargetVertices[BindingId].Item2;
                        if (list.Contains(point.Index))
                            list.Remove(point.Index);
                        //if (list.Count == 0)
                        //    b._influencedVertices.Remove(BindingId);
                        //}
                    }
                }
            }
        }
        public void SkeletonChanged(ISkeleton skeleton)
        {
            LinkMeshToSkeleton(false);
            
            _modifiedBoneIndicesUpdating.Clear();
            var matrixIdsBuffer = _mesh[EBufferType.MatrixIds];
            if (matrixIdsBuffer != null)
            {
                matrixIdsBuffer.Destroy();
                _mesh.Buffers.RemoveAt(_mesh.Buffers.Count - 1);
            }
            var matrixWeightsBuffer = _mesh[EBufferType.MatrixIds];
            if (matrixWeightsBuffer != null)
            {
                matrixWeightsBuffer.Destroy();
                _mesh.Buffers.RemoveAt(_mesh.Buffers.Count - 1);
            }
            _boneMatrixBuffer?.Dispose();
            _boneMatrixBuffer = null;

            if (_utilizedBones != null)
                foreach (IBone b in _utilizedBones)
                {
                    b.RemovePrimitiveManager(this);
                    b.Renamed -= BoneRenamed;
                }

            SingleBind = null;
            
            _boneRemap = null;
            if (skeleton != null)
            {
                if (_mesh.UtilizedBones is null || _mesh.UtilizedBones.Length <= 1)
                {
                    if (!string.IsNullOrEmpty(_mesh.SingleBindBone) && skeleton.BoneNameCache.ContainsKey(_mesh.SingleBindBone))
                        SingleBind = skeleton.BoneNameCache[_mesh.SingleBindBone];
                    
                    _cpuSkinInfo = null;
                }
                else if (_mesh.Influences != null && _mesh.Influences.Length > 0)
                {
                    int facePointCount = _mesh.FacePoints.Count;
                    if (Engine.Settings.UseIntegerWeightingIds || !Engine.Settings.SkinOnGPU)
                    {
                        if (Engine.Settings.SkinOnGPU)
                        {
                            _cpuSkinInfo = null;
                            IVec4[] matrixIndices = new IVec4[facePointCount];
                            Vec4[] matrixWeights = new Vec4[facePointCount];

                            for (int i = 0; i < facePointCount; ++i)
                            {
                                matrixIndices[i] = new IVec4();
                                matrixWeights[i] = new Vec4();
                                InfluenceDef inf = _mesh.Influences[_mesh.FacePoints[i].InfluenceIndex];
                                for (int j = 0; j < InfluenceDef.MaxWeightCount; ++j)
                                {
                                    BoneWeight weight = inf.Weights[j];
                                    int index;
                                    if (weight is null || (index = _mesh.UtilizedBones.IndexOf(weight.Bone)) < 0)
                                    {
                                        matrixIndices[i][j] = 0;
                                        matrixWeights[i][j] = 0.0f;
                                    }
                                    else
                                    {
                                        matrixIndices[i][j] = index + 1;
                                        matrixWeights[i][j] = weight.Weight;
                                    }
                                }
                            }

                            _mesh.AddBuffer(matrixIndices, new VertexAttribInfo(EBufferType.MatrixIds), false, true);
                            _mesh.AddBuffer(matrixWeights, new VertexAttribInfo(EBufferType.MatrixWeights));

                            _rigInvalidated = true;
                            //Destroy();
                            //Generate();
                        }
                        else
                            _cpuSkinInfo = new CPUSkinInfo(_mesh, skeleton);
                    }
                    else
                    {
                        Vec4[] matrixIndices = new Vec4[facePointCount];
                        Vec4[] matrixWeights = new Vec4[facePointCount];

                        for (int i = 0; i < facePointCount; ++i)
                        {
                            matrixIndices[i] = new Vec4();
                            matrixWeights[i] = new Vec4();
                            InfluenceDef inf = _mesh.Influences[_mesh.FacePoints[i].InfluenceIndex];
                            for (int j = 0; j < InfluenceDef.MaxWeightCount; ++j)
                            {
                                BoneWeight weight = inf.Weights[j];
                                int index;
                                if (weight is null || (index = _mesh.UtilizedBones.IndexOf(weight.Bone)) < 0)
                                {
                                    matrixIndices[i][j] = 0.0f;
                                    matrixWeights[i][j] = 0.0f;
                                }
                                else
                                {
                                    matrixIndices[i][j] = index + 1;
                                    matrixWeights[i][j] = weight.Weight;
                                }
                            }
                        }
                        _cpuSkinInfo = null;

                        _mesh.AddBuffer(matrixIndices, new VertexAttribInfo(EBufferType.MatrixIds), false, false);
                        _mesh.AddBuffer(matrixWeights, new VertexAttribInfo(EBufferType.MatrixWeights));

                        _rigInvalidated = true;
                        //Destroy();
                        //Generate();
                    }

                    _utilizedBones = _mesh.UtilizedBones.Select(x => skeleton.BoneNameCache[x]).ToArray();

                    foreach (Bone b in _utilizedBones)
                        b.Renamed += BoneRenamed;

                    _boneMatrixBuffer = new DataBuffer("BoneMatrices", EBufferTarget.UniformBuffer, false)
                    {
                        MapData = false,
                        Usage = EBufferUsage.DynamicDraw,
                    };
                    List<Matrix4> matrices = _utilizedBones.Select(x => x.VertexMatrix).ToList();
                    matrices.Insert(0, Matrix4.Identity);
                    _boneMatrixBuffer.SetData(matrices, false);
                    _rigInvalidated = true;
                    _boneRemap = new Dictionary<int, int>();
                    for (int i = 0; i < _utilizedBones.Length; ++i)
                    {
                        IBone b = _utilizedBones[i];

                        _modifiedBoneIndicesUpdating.Add(b.Index);

                        //b.AddPrimitiveManager(this);
                        _boneRemap.Add(b.Index, i);
                    }
                }
            }
            else
            {
                _utilizedBones = null;
            }
            LinkMeshToSkeleton(true);
            SwapBuffers();
        }

        private void BoneRenamed(TObject node, string oldName)
        {
            if (node is Bone b)
            {
                int index = _utilizedBones.IndexOf(b);
                if (_utilizedBones.IndexInRange(index))
                    _utilizedBones[index] = b;
            }
        }

        private void SingleBindRenamed(TObject node, string oldName)
        {
            _mesh.SingleBindBone = node.Name;
        }

        private DataBuffer _boneMatrixBuffer;
        private void SetSkinningUniforms(RenderProgram program)
        {
            if (!BufferInfo.IsWeighted)
                return;
            
            if (Engine.Settings.SkinOnGPU)
            {
                if (_boneMatrixBuffer != null)
                {
                    if (_modifiedBoneIndicesRendering.Count > 0)
                    {
                        Matrix4 vtxMtx;
                        int boneIndex;
                        foreach (int i in _modifiedBoneIndicesRendering)
                        {
                            boneIndex = _boneRemap[i];
                            vtxMtx = _utilizedBones[boneIndex].VertexMatrix;

                            //Increment the bone index to account for the identity matrix at index 0
                            _boneMatrixBuffer.Set(boneIndex + 1, vtxMtx);
                        }
                        //Engine.Renderer.Uniform(Uniform.MorphWeightsName, _morphWeights);
                    }

                    _boneMatrixBuffer.SetBlockName(program, "Bones");
                    _boneMatrixBuffer.PushSubData(0, _boneMatrixBuffer.DataLength);
                }
            }
            else
            {
                _cpuSkinInfo?.UpdatePNBT(_modifiedVertexIndicesRendering);
            }
        }
        /// <summary>
        /// Retrieves the linked material's uniform parameter at the given index.
        /// Use this to set uniform values to be passed to the shader.
        /// </summary>
        public T2 Parameter<T2>(int index) where T2 : ShaderVar
        {
            if (index >= 0 && index < Material.Parameters.Length)
                return Material.Parameters[index] as T2;
            throw new IndexOutOfRangeException();
        }
        /// <summary>
        /// Retrieves the linked material's uniform parameter with the given name.
        /// Use this to set uniform values to be passed to the shader.
        /// </summary>
        public T2 Parameter<T2>(string name) where T2 : ShaderVar
            => Material.Parameters.FirstOrDefault(x => x.Name == name) as T2;
        private Matrix4 _lastRenderedModelMatrix = Matrix4.Identity;

        internal TMaterial GetRenderMaterial(TMaterial localOverrideMat)
            => Engine.Renderer.MeshMaterialOverride ?? localOverrideMat ?? Material;

        public void Render()
            => Render(1);
        public void Render(int instances) 
            => Render(Matrix4.Identity, Matrix3.Identity, instances);
        public void Render(Matrix4 modelMatrix, int instances = 1) 
            => Render(modelMatrix, modelMatrix.Inverted().Transposed().GetRotationMatrix3(), instances);
        public void Render(Matrix4 modelMatrix, TMaterial materialOverride, int instances = 1)
            => Render(modelMatrix, modelMatrix.Inverted().Transposed().GetRotationMatrix3(), materialOverride, instances);
        public void Render(Matrix4 modelMatrix, Matrix3 normalMatrix, int instances = 1)
            => Render(modelMatrix, normalMatrix, null, instances);
        public void Render(Matrix4 modelMatrix, Matrix3 normalMatrix, TMaterial materialOverride, int instances = 1)
        {
            if (_mesh is null || !_allowRender)
                return;

            TMaterial mat = GetRenderMaterial(materialOverride);
            if (mat is null)
                return;

            if (_rigInvalidated)
            {
                Destroy();
                for (int i = 0; i < _utilizedBones.Length; ++i)
                {
                    IBone b = _utilizedBones[i];
                    b.AddPrimitiveManager(this);
                }
                if (_boneMatrixBuffer != null)
                {
                    _boneMatrixBuffer.Destroy();
                    _boneMatrixBuffer.Generate();
                    _boneMatrixBuffer.PushData();
                }
                _rigInvalidated = false;
            }

            if (!IsActive)
                Generate();

            if (_singleBind != null)
            {
                modelMatrix *= _singleBind.VertexMatrix;
                normalMatrix *= _singleBind.VertexMatrix.Inverted().Transposed().GetRotationMatrix3();
            }

            RenderProgram vtxProg, matProg;
            if (Engine.Settings.AllowShaderPipelines)
            {
                matProg = mat.Program;

                _pipeline.Bind();
                _pipeline.Clear(EProgramStageMask.AllShaderBits);
                _pipeline.Set(mat.Program.ShaderTypeMask, matProg.BindingId);

                //If the program doesn't override the vertex shader, use the default one for this mesh
                if (!mat.Program.ShaderTypeMask.HasFlag(EProgramStageMask.VertexShaderBit))
                {
                    vtxProg = _vertexProgram;
                    _pipeline.Set(EProgramStageMask.VertexShaderBit, vtxProg.BindingId);
                }
                else
                    vtxProg = matProg;
            }
            else
            {
                if (VertexFragProgram is null)
                {
                    VertexFragProgram = new RenderProgram(Material.FragmentShaders[0], _vertexShader);
                    //_vertexFragProgram.Generate();
                }
                vtxProg = matProg = VertexFragProgram;
                VertexFragProgram.Use();
            }
            
            SetSkinningUniforms(vtxProg);
            
            vtxProg.Uniform(Uniform.GetLocation(vtxProg, EEngineUniform.ModelMatrix), modelMatrix);
            //Engine.Renderer.Uniform(vtxId, Uniform.GetLocation(vtxId, ECommonUniform.PrevModelMatrix), _lastRenderedModelMatrix);
            vtxProg.Uniform(Uniform.GetLocation(vtxProg, EEngineUniform.NormalMatrix), normalMatrix);

            Matrix4 worldToCam = Matrix4.Identity;
            Matrix4 proj = Matrix4.Identity;

            if (Engine.Renderer.CurrentCamera != null)
            {
                vtxProg.Uniform(Uniform.GetLocation(vtxProg,
                    EEngineUniform.WorldToCameraSpaceMatrix),
                    Engine.Renderer.CurrentCamera.WorldToCameraSpaceMatrix);

                vtxProg.Uniform(Uniform.GetLocation(vtxProg,
                    EEngineUniform.ProjMatrix),
                    Engine.Renderer.CurrentCamera.ProjectionMatrix);
            }
            else
            {
                //No camera? Everything will be rendered in world space instead of camera space.
                //This is used by point lights to render depth cubemaps, for example.

                vtxProg.Uniform(Uniform.GetLocation(vtxProg, 
                    EEngineUniform.WorldToCameraSpaceMatrix), 
                    Matrix4.Identity);

                vtxProg.Uniform(Uniform.GetLocation(vtxProg,
                    EEngineUniform.ProjMatrix),             
                    Matrix4.Identity);
            }

            mat.SetUniforms(matProg);

            OnSettingUniforms(vtxProg, matProg);
            
            Engine.Renderer.RenderPrimitiveManager(this, false, Instances);
            _lastRenderedModelMatrix = modelMatrix;
        }
        private void OnSettingUniforms(RenderProgram vertexProgram, RenderProgram materialProgram)
            => SettingUniforms?.Invoke(vertexProgram, materialProgram);
        protected override void PostGenerated()
        {
            //Create vertex shader program here
            if (Engine.Settings.AllowShaderPipelines)
            {
                _vertexProgram = new RenderProgram(_vertexShader);
                //_vertexProgram.Generate();
            }
            else
            {
                if (VertexFragProgram is null)
                {
                    VertexFragProgram = new RenderProgram(Material.FragmentShaders[0], _vertexShader);
                    //_vertexFragProgram.Generate();
                }
            }
            
            Engine.Renderer.BindPrimitiveManager(this);
            _bindingIds = _mesh.GenerateBuffers(BindingId);
            IndexBuffer._vaoId = BindingId;
            IndexBuffer.Generate();
            Engine.Renderer.LinkRenderIndices(this, IndexBuffer);
            Engine.Renderer.BindPrimitiveManager(null);
        }
        protected override void PostDeleted()
        {
            _pipeline?.Destroy();
            _vertexProgram?.Destroy();
            VertexFragProgram?.Destroy();
        }
        protected override void Dispose(bool disposing)
        {
            base.Dispose(disposing);
            if (!_disposedValue)
            {
                if (disposing)
                {
                    Destroy();
                }
                
                _mesh.Dispose();
                IndexBuffer.Dispose();
                _vertexProgram = null;
                VertexFragProgram = null;

                _disposedValue = true;
            }
        }
    }
}
