const float PI = 3.14159265359;
const float InvPI = 0.31831;

//Trowbridge-Reitz GGX
float SpecD_TRGGX(float NoH2, float a2)
{
    	float num    = a2;
    	float denom  = (NoH2 * (a2 - 1.0) + 1.0);
    	denom        = PI * denom * denom;

    	return num / denom;
}
float SpecG_SchlickGGX(float NdotV, float k)
{
    	float num   = NdotV;
   	float denom = NdotV * (1.0 - k) + k;

    	return num / denom;
}
float SpecG_Smith(float NoV, float NoL, float k)
{
    	float ggx1 = SpecG_SchlickGGX(NoV, k);
    	float ggx2 = SpecG_SchlickGGX(NoL, k);
    	return ggx1 * ggx2;
}
vec3 SpecF_Schlick(float VoH, vec3 F0)
{
	//Regular implementation
	//float pow = pow(1.0 - VoH, 5.0);

	//Spherical Gaussian Approximation
	//https://seblagarde.wordpress.com/2012/06/03/spherical-gaussien-approximation-for-blinn-phong-phong-and-fresnel/
	float pow = exp2((-5.55473 * VoH - 6.98316) * VoH);

    	return F0 + (1.0 - F0) * pow;
}
vec3 Spec_CookTorrance(float D, float G, vec3 F, float NoV, float NoL)
{
	vec3 num = D * G * F;
	float denom = 4.0 * NoV * NoL + 0.001; 
	return num / denom;
}
vec3 CalcLighting(vec3 N, vec3 L, vec3 color, float roughness, float metallic, float ior)
{
	float NoV = max(dot(N, V), 0.0);
	float NoL = max(dot(N, L), 0.0);
	float NoH = max(dot(N, H), 0.0);
	float NoH2 = NoH * NoH;

	float a = roughness * roughness;
	float a2 = a * a;

	float k = pow(roughness + 1.0, 2.0) * 0.125; //divide by 8

	float D = SpecD_TRGGX(NoH2, a2);
	float G = SpecG_Smith(NoV, NoL, k);
	float F = SpecF_Schlick(VoH, F0);

	float NdotH  = max(dot(N, H), 0.0);
    	float NdotH2 = NdotH * NdotH;

	vec3 F0 = abs((1.0 - ior) / (1.0 + ior));
	F0      = mix(F0, color, metallic);
 
	vec3 kS = F;
	vec3 kD = (vec3(1.0) - kS) * (1.0 - metallic);

	vec3 specular = Spec_CookTorrance(D, G, F, NoV, NoL);
	return kd * color * InvPI + ks * specular;
      
    	Lo += CalcLighting() * radiance * NoL;
}

vec3 ImportanceSampleGGX(vec2 Xi, float a, vec3 N)
{
	float Phi = 2.0 * PI * Xi.x;

	float CosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a * a - 1.0) * Xi.y));
	float SinTheta = sqrt(1.0 - CosTheta * CosTheta);

	vec3 H = vec3(SinTheta * cos(Phi), SinTheta * sin(Phi), CosTheta);
	vec3 UpVector = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);
	vec3 TangentX = normalize(cross(UpVector, N));
	vec3 TangentY = cross(N, TangentX);

	// Tangent to world space
	return TangentX * H.x + TangentY * H.y + N * H.z;
}
vec3 SpecularIBL(vec3 SpecularColor, float Roughness, vec3 N, vec3 V)
{
	const uint NumSamples = 1024;

	vec3 radiance = vec3(0.0);
	float a = Roughness * Roughness;
	for (uint i = 0; i < NumSamples; i++)
	{
		vec2 Xi = Hammersley(i, NumSamples);
		vec3 H = ImportanceSampleGGX(Xi, a, N);
		float VoH = dot(V, H);
		vec3 L = 2 * VoH * H - V;
		float NoV = saturate(dot(N, V));
		float NoL = saturate(dot(N, L));
		float NoH = saturate(dot(N, H));
		VoH = saturate(VoH);
		if(NoL > 0)
		{
			vec3 SampleColor = EnvMap.SampleLevel(EnvMapSampler, L, 0).rgb;
			float G = G_Smith(Roughness, NoV, NoL);
			float Fc = pow( 1 - VoH, 5 );
			float3 F = (1 - Fc) * SpecularColor + Fc;
			// Incident light = SampleColor * NoL
			// Microfacet specular = D*G*F / (4*NoL*NoV)
			// pdf = D * NoH / (4 * VoH)
			radiance += SampleColor * F * G * VoH / (NoH * NoV);
		}
	}
	return radiance / NumSamples;
}